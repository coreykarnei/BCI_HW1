function ep_artifactCorrection(varargin);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ep_artifactCorrection(varargin);% Handles the process of splitting up parts of the files, doing the correction, and then rejoining them.%%	Reads in file chunks generated by readEGISses function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA in a 1GB.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.  It will need a channel%	coordinates file in the EEGlab .ced format.  It will assume that the%	first three entries are fiducials and drop them.  It will assume that%	the next set of entries are the electrodes and will ignore any extras%	at the end.  It will also assume that all the files in a given batch have the same electrode montage.%%Keywords - all optional (defaults in parentheses)%   files: followed by cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)%   inputFormat: followed by input file format.%   outputFormat: followed by output file format.%   baseline: followed by array of sample numbers to permanently baseline correct the trials with.  [] means don't correct. (default: [])%   template: followed by source of blink template (fileTemplate: load blink format file.  autoTemplate: automatically generate blink template.%               bothTemplate: use both file and automatic template at the same time) (default: autotemplate)%   blinkFile: path and name of the blink file if using the FileTemplate or bothTemplate options.%   badChans: followed by cell array of bad channels to exclude from blink detection process (default: [])%   saturation: followed by range of non-saturated data values (default: -inf to +inf)%   eog: followed by structured array with EOG channels (LUVEOG, RUVEOG, LLVEOG, RLVEOG, LHEOG, RHEOG)%               (must be provided by either eog keyword or by auto-detection of montage from original file.)%   window:    moving average window for smoothing during bad channel detection only (default: 80 ms)%   minmax:    difference from minimum to maximum for bad channel (default: 100 였)%   badnum:    percent of bad channels exceeded to declare bad trial, rounding down (default: 10)%   hminmax:   difference from minimum to maximum for bad horizontal EOG (default: 55 였)%   neighbors: number of electrodes considered to be neighbors (default: 6)%   maxneighbor:   maximum microvolt difference allowed from best matching neighbor (default: 30 였)%   badchan:   minimum predictability from neighbors to not be considered globally bad (default: .4)%   blink:     threshold correlation with blink template, 0 to 1 (default: .9)%   trialminmax:  difference from minimum to maximum for bad trial (default: 100 였)%   detrend:   1 to detrend (0).  Helpful for very noisy data but can result in late effects%              being distributed across the entire epoch so otherwise not recommended.%              Credit to Hyunseok Kook.%   badtrials: percentage of good trials chan is bad to declare a channel globally bad (default: 20)%   channelMode:   'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing. (default: replace)%   trialMode:   'fix' to fix bad trial data and 'none' to do nothing. (default: fix)%   noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad) (default: 1)%   chunkSize: Number of timepoints to read in.  Roughly 100000 per GB of memory available. (default: 100,000)%   minTrialsPerCell: Minimum number of good trials per cell to avoid warning message. (default: 15)%   movefacs  : number of factors to retain during movement correction.%   noFigure  : 1 to disable summary figures of artifact detection (to help cope with low memory situations).%%Outputs%	Saves files with blinks removed.  Uses original name with "_e" appended to the stem.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%   finalLog: output messages from blink process%% History:%% by Joseph Dien (2/17/08)% jdien07@mac.com%%% modified 11/20/08 JD% Changed to keyword approach.  Made baseline specification more flexible.% Changed to use FieldTrip I/O in order to be able to read more formats.%% modified and bugfix 2/11/09 JD% Changed to allow selection of multiple files from selector.  Problematic% files do not stop entire batch.  More information added to log file.  Bad% channel and trial detection implemented.  Blinkfile template option crash fixed.% Fixed crash when selecting a single file with the file requestor.%% modified 3/25/09 JD% Changed to use readData and writeData functions to provide more flexibility with I/O functions.% Now relies on readData to obtain the .ced file name.%% modified 4/17/09 JD% eloc and ced now handled by readData.%% modified 7/14/09 JD% Added none option to blink template.  Changed 'replace' keyword to 'channelMode'.  Added 'trialMode'.% Single summary figure for full artifact correction procedure.  Changing name of function to% artifactCorrection from blinkCorrecction.  Doesn't require two vertical EOG channels% if using file template.  Uses updated blink template format.%% bugfix 8/27/09 JD% Location of windows appearing partly off screen on some systems.  Fixed.%% bugfix & modified 8/30/09 JD% Was setting all data formats to EGIS.  Added support for continuous data.%% bugfix & modified 9/16/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.% Slashes in log file being interpreted as control characters.% Trialwise bad channel detection deactivated for continuous data.%% bugfix 9/23/09 JD% When input files were split into multiple chunks, only the final one's progress window was being closed.% In batch runs the windows would accumulate and eventually result in a memory error.%% bugfix 10/17/09 JD% Continuous data crashed artifact correction.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 10/31/09 JD% When there are multiple chunks, only saving the figure for the final one.%% bugfix 12/5/09 JD% Avoid performing trialwise bad channel detection entirely unless both minmax and maxneighbor parameters are inactive.% Fixed crash when more than one bad channel.% Now assumes montages are all the same, not just the channel coordinates.%% modified & bugfix 2/24/10 JD% No longer treating shorted channels as being bad channels as this was proving too conservative a criterion.  Instead% it now just provides a warning message.% Will now work with subject average files with multiple subjects.% Turning off bad channel preferences affects only the relevant bad channel criteria rather than turning off all bad% channel detection.% Now uses file's reference settings if not specified in the Preprocess pane.% Added log to bad channel detection function output.%% modified 6/15/10 JD% Added name of first session file to the name of the log file if just one or the number of files if more.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2010  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.ep_initEP;baseline=[];montage=[];sessionFiles=[];outputFormat='egi_egis';inputFormat='egi_egis';template='autoTemplate';blinkFile=[];badChans=[];saturation=[-inf inf];chunkSize=100000;eog=[];refChan=[];noFigure=0;ced = 'none';badDataCriteria.window=80;badDataCriteria.minmax=100;badDataCriteria.trialminmax=100;badDataCriteria.badnum=10;badDataCriteria.hminmax=55;badDataCriteria.neighbors=6;badDataCriteria.badchan=.4;badDataCriteria.maxneighbor=30;badDataCriteria.blink=.9;badDataCriteria.detrend=0;badDataCriteria.badtrials=20;badDataCriteria.channelMode='replace';badDataCriteria.trialMode='fix';badDataCriteria.noadjacent=1;badDataCriteria.movefacs=20;minTrialsPerCell=15;scrsz = get(0,'ScreenSize');if ~isempty(varargin)    if isa(varargin{1},'cell') && nargin==1 %if keywords were input as a single cell string        inputSet=varargin{1};    else        inputSet=varargin;    end;else    inputSet=[];end;argNum=length(inputSet);if mod(argNum,2) ~= 0    error('The keywords need to all be in pairs, with a keyword followed by the keyword information.');end;readArg=[];argCount=1;while argCount <= argNum    switch inputSet{argCount}        case 'files'            argCount=argCount+1;            if argCount > argNum                error('The ''files'' keyword must be followed by a set of file names.');            end;            if ~iscell(inputSet{argCount})                error('The ''files'' keyword must be followed by a set of file names.');            end;            sessionFiles=inputSet{argCount};            argCount=argCount+1;        case 'inputFormat'            argCount=argCount+1;            if argCount > argNum                error('The ''inputFormat'' keyword must be followed by a format name.');            end;            if ~ischar(inputSet{argCount})                error('The ''inputFormat'' keyword must be followed by a format name.');            end;            inputFormat=inputSet{argCount};            readArg{end+1}='format';            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;        case 'outputFormat'            argCount=argCount+1;            if argCount > argNum                error('The ''outputFormat'' keyword must be followed by a format name.');            end;            if ~ischar(inputSet{argCount})                error('The ''outputFormat'' keyword must be followed by a format name.');            end;            outputFormat=inputSet{argCount};            argCount=argCount+1;        case 'baseline'            argCount=argCount+1;            if argCount > argNum                error('The ''baseline'' keyword must be followed by a list of samples.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''baseline'' keyword must be followed by a set of numbers (e.g., [1:50]).');            end;            baseline=inputSet{argCount};            argCount=argCount+1;        case 'template'            argCount=argCount+1;            if argCount > argNum                error('The ''template'' keyword must be followed by the template option.');            end;            if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','none'}))                error('The ''template'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'', ''none''.');            end;            template=inputSet{argCount};            argCount=argCount+1;        case 'blinkFile'            argCount=argCount+1;            if argCount > argNum                error('The ''blinkFile'' keyword must be followed by the blink file name.');            end;            if ~ischar(inputSet{argCount})                error('The ''blinkFile'' keyword must be followed by the blink file name.');            end;            blinkFile=inputSet{argCount};            argCount=argCount+1;        case 'badChans'            argCount=argCount+1;            if argCount > argNum                error('The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).');            end;            if ~iscell(inputSet{argCount})                error('The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).');            end;            badChans=inputSet{argCount};            argCount=argCount+1;        case 'saturation'            argCount=argCount+1;            if argCount > argNum                error('The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).');            end;            if ~isnumeric(inputSet{argCount}) || length(inputSet{argCount}) ~= 2                error('The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).');            end;            saturation=inputSet{argCount};            argCount=argCount+1;        case 'eog'            argCount=argCount+1;            if argCount > argNum                error('The ''eog'' keyword must be followed by an array with the six EOG channels.');            end;            eog2=inputSet{argCount};            if ~isempty(eog2)                if ~isnumeric(eog2) || length(eog2) ~= 6                    error('The ''eog'' keyword must be followed by an array with the six EOG channels.');                end;            end;            eog.LUVEOG = eog2(1);            eog.RUVEOG = eog2(2);            eog.LLVEOG = eog2(3);            eog.RLVEOG = eog2(4);            eog.LHEOG = eog2(5);            eog.RHEOG = eog2(6);            argCount=argCount+1;        case 'window'            argCount=argCount+1;            if argCount > argNum                error('The ''window'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''window'' keyword must be followed by the criterion number.');            end;            badDataCriteria.window=inputSet{argCount};            argCount=argCount+1;        case 'minmax'            argCount=argCount+1;            if argCount > argNum                error('The ''minmax'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''minmax'' keyword must be followed by the criterion number.');            end;            badDataCriteria.minmax=inputSet{argCount};            argCount=argCount+1;        case 'trialminmax'            argCount=argCount+1;            if argCount > argNum                error('The ''trialminmax'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''trialminmax'' keyword must be followed by the criterion number.');            end;            badDataCriteria.trialminmax=inputSet{argCount};            argCount=argCount+1;        case 'badnum'            argCount=argCount+1;            if argCount > argNum                error('The ''badnum'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''badnum'' keyword must be followed by the criterion number.');            end;            if badDataCriteria.badnum < 0 || badDataCriteria.badnum > 100                error('The ''badnum'' number must be between 0 and 100.');            end;            badDataCriteria.badnum=inputSet{argCount};            argCount=argCount+1;        case 'hminmax'            argCount=argCount+1;            if argCount > argNum                error('The ''hminmax'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''hminmax'' keyword must be followed by the criterion number.');            end;            badDataCriteria.hminmax=inputSet{argCount};            argCount=argCount+1;        case 'neighbors'            argCount=argCount+1;            if argCount > argNum                error('The ''neighbors'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''neighbors'' keyword must be followed by the criterion number.');            end;            badDataCriteria.neighbors=inputSet{argCount};            argCount=argCount+1;        case 'maxneighbor'            argCount=argCount+1;            if argCount > argNum                error('The ''maxneighbor'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''maxneighbor'' keyword must be followed by the criterion number.');            end;            badDataCriteria.maxneighbor=inputSet{argCount};            argCount=argCount+1;        case 'badchan'            argCount=argCount+1;            if argCount > argNum                error('The ''badchan'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''badchan'' keyword must be followed by the criterion number.');            end;            if badDataCriteria.badchan < 0 || badDataCriteria.badchan > 1                error('The ''badchan'' number must be between 0 and 1.');            end;            badDataCriteria.badchan=inputSet{argCount};            argCount=argCount+1;        case {'blink', 'blinks'}            argCount=argCount+1;            if argCount > argNum                error('The ''blink'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''blink'' keyword must be followed by the criterion number.');            end;            badDataCriteria.blink=inputSet{argCount};            if badDataCriteria.blink < 0 || badDataCriteria.blink > 1                error('The ''blink'' number must be between 0 and 1.');            end;            argCount=argCount+1;        case 'detrend'            argCount=argCount+1;            if argCount > argNum                error('The ''detrend'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''detrend'' keyword must be followed by the criterion number.');            end;            badDataCriteria.detrend=inputSet{argCount};            if badDataCriteria.detrend ~= 0 && badDataCriteria.detrend ~= 1                error('The ''detrend'' number must be either 0 or 1.');            end;            if badDataCriteria.detrend ==1                disp('Warning: detrending can distribute an effect across the entire epoch.  Use with care.');            end;            argCount=argCount+1;        case 'badtrials'            argCount=argCount+1;            if argCount > argNum                error('The ''badtrials'' keyword must be followed by the criterion number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''badtrials'' keyword must be followed by the criterion number.');            end;            if badDataCriteria.badtrials < 0 || badDataCriteria.badtrials > 100                error('The ''badtrials'' number must be between 0 and 100.');            end;            badDataCriteria.badtrials=inputSet{argCount};            argCount=argCount+1;        case 'channelMode'            argCount=argCount+1;            if argCount > argNum                error('The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.');            end;            if ~ischar(inputSet{argCount})                error('The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.');            end;            if ~any(strcmp(inputSet{argCount},{'replace','mark','none'}))                error('The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.');            end;            badDataCriteria.channelMode=inputSet{argCount};            argCount=argCount+1;        case 'trialMode'            argCount=argCount+1;            if argCount > argNum                error('The ''trialMode'' keyword must be followed by ''fix'' or ''none''.');            end;            if ~ischar(inputSet{argCount})                error('The ''trialMode'' keyword must be followed by ''fix'' or ''none''.');            end;            if ~any(strcmp(inputSet{argCount},{'fix','none'}))                error('The ''trialMode'' keyword must be followed by ''fix'' or ''none''.');            end;            badDataCriteria.trialMode=inputSet{argCount};            argCount=argCount+1;        case 'noadjacent'            argCount=argCount+1;            if argCount > argNum                error('The ''noadjacent'' keyword must be followed by 0 or 1.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''noadjacent'' keyword must be followed by 0 or 1.');            end;            badDataCriteria.noadjacent=inputSet{argCount};            if badDataCriteria.noadjacent ~= 0 && badDataCriteria.noadjacent ~= 1                error('The ''noadjacent'' number must be either 0 or 1.');            end;            argCount=argCount+1;        case 'chunkSize'            argCount=argCount+1;            if argCount > argNum                error('The ''chunkSize'' keyword must be followed by the chunk size number.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''chunkSize'' keyword must be followed by the chunk size number.');            end;            chunkSize=inputSet{argCount};            argCount=argCount+1;        case 'minTrialsPerCell'            argCount=argCount+1;            if argCount > argNum                error('The ''minTrialsPerCell'' keyword must be followed by a number of trials.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''minTrialsPerCell'' keyword must be followed by a number of trials.');            end;            minTrialsPerCell=inputSet{argCount};            argCount=argCount+1;        case 'movefacs'            argCount=argCount+1;            if argCount > argNum                error('The ''movefacs'' keyword must be followed by a number of factors.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''movefacs'' keyword must be followed by a number of factors.');            end;            badDataCriteria.movefacs=inputSet{argCount};            argCount=argCount+1;        case 'reference'            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;            if argCount > argNum                error('The ''reference'' keyword must be followed by the reference channel(s).');            end;            if ~isnumeric(inputSet{argCount})                error('The ''reference'' keyword must be followed by the reference channel(s).');            end;            refChan=inputSet{argCount};            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;        case 'noFigure'            argCount=argCount+1;            if argCount > argNum                error('The ''noFigure'' keyword must be followed by 0 or 1.');            end;            if ~isnumeric(inputSet{argCount})                error('The ''noFigure'' keyword must be followed by 0 or 1.');            end;            noFigure=inputSet{argCount};            if noFigure ~= 0 && noFigure ~= 1                error('The ''noFigure'' number must be either 0 or 1.');            end;            argCount=argCount+1;        otherwise            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;    end;end;if any(strcmp(template, {'fileTemplate','bothTemplate'})) && isempty(blinkFile)    blinkFile = 'blinks';end;if ~strcmp('format',readArg)    readArg{end+1}='format';    readArg{end+1}='egi_egis';end;if isempty(sessionFiles)    [sessionFiles, pathname] = uigetfile('*.*','Open:','MultiSelect','on');    activeDirectory=pathname;    if ~iscell(sessionFiles)        temp=sessionFiles;        sessionFiles=[];        sessionFiles{1}=temp;    end;    if sessionFiles{1}==0        disp(' ');        disp('**************************************************************');        disp('No filenames selected. You have to click on a name');        disp('**************************************************************');        disp(' ');        return    end    if ~iscell(sessionFiles)        temp=sessionFiles;        sessionFiles=[];        sessionFiles{1}=temp;    end;    for theFile=1:size(sessionFiles,2)        sessionFiles{theFile}=[activeDirectory sessionFiles{theFile}];    end;else    files=dir;    for theFile=1:size(sessionFiles,2)        [activeDirectory, name, ext, versn] = fileparts(sessionFiles{theFile});        if isempty(activeDirectory)            activeDirectory=pwd;            sessionFiles{theFile}=[activeDirectory filesep sessionFiles{theFile}];        end;        if ~exist(sessionFiles{theFile},'file')            disp(' ');            disp('**************************************************************');            disp(['Error: The file ' sessionFiles{theFile} ' is not in the directory.']);            disp('**************************************************************');            disp(' ');            return;        end;    end;end;sessionFiles=sessionFiles';sessionNum = size(sessionFiles,1);finalLog{1}='ARTIFACT CORRECTION SUMMARY';if isempty(badChans) || (length(badChans) == 1) && (isempty(badChans{1}))    badChans=num2cell(zeros(sessionNum,1));end;if (size(sessionFiles,1) ~= size(badChans,1))    error('Must specify a set of bad channels for each subject.');end;if exist('icadefs','file') ~= 2    disp(' ');    disp('**************************************************************');    disp('Error: ICA not available.  You need to download EEGlab and then add it to Matlab''s path list.');    disp('See tutorial file for details.');    disp('**************************************************************');    disp(' ');    returnend;icadefs;if any(isspace(pwd)) && exist(ICABINARY,'file') == 2    disp(['Binary ICA does not work if any part of the pathname (' pwd ') has a space in it.']);    disp('Will use regular ICA instead.');end;%assume the first session file is representative of the rest.Name=deblank(sessionFiles{1});thisReadArg=readArg;thisReadArg{end+1}='file';[pathstr, fileName, ext, versn]=fileparts(Name);thisReadArg{end+1}=Name;data=ep_readData(thisReadArg);if isempty(data)    disp(' ');    disp('**************************************************************');    disp(['Error: The file ' sessionFiles{1} ' was not read successfully.']);    disp('**************************************************************');    disp(' ');    return;end;[data]=ep_stripAdds(data);if isempty(data.ced)    disp(' ');    disp('**************************************************************');    disp(['Error: The file ' sessionFiles{1} ' has no information on channel locations.  .ced file needed.']);    disp('**************************************************************');    disp(' ');    return;end;if (length([data.eloc.theta]) < length(data.eloc)) || (length([data.eloc.radius]) < length(data.eloc))    disp(' ');    disp('**************************************************************');    disp(['Error: The file ' sessionFiles{1} ' is missing information on some of the channel locations needed.']);    disp('**************************************************************');    disp(' ');    return;end;if isempty(data.data)    disp(' ');    disp('**************************************************************');    disp(['Error: The file ' sessionFiles{1} ' had no data left to correct after additions were removed.']);    disp('**************************************************************');    disp(' ');    return;end;if ~isempty(eog) && ~isempty(data.montage)    disp('Montage info will override eog channel settings.');end;% if ~isempty(montage)%     [eog2] = ep_EOGchannels(montage);%     if ~isempty(eog2)%         if ~isempty(eog)%             disp('Montage info will override eog channel settings.');%         end;%         eog=eog2;%     end;% end;nChans=length(data.chanNames);for theFile=2:size(sessionFiles,2)    Name2=deblank(sessionFiles{theFile});    thisReadArg2=readArg;    thisReadArg2{end+1}='file';    [pathstr, fileName, ext, versn]=fileparts(Name2);    thisReadArg2{end+1}=[fileName ext];    thisReadArg2{end+1}='silent';    thisReadArg2{end+1}='on';    thisReadArg2{end+1}='ced';    thisReadArg2{end+1}=data.ced; %assume they all have the same channel coordinates    thisReadArg2{end+1}='montage';    thisReadArg2{end+1}=data.montage; %assume they all have the same montage    data2=ep_readData(thisReadArg2);    [data2]=ep_stripAdds(data2);    if (nChans ~= length(data2.chanNames))        disp(' ');        disp('**************************************************************');        disp(['Error: The file ' sessionFiles{theFile} ' has a different set of electrodes.']);        disp('**************************************************************');        disp(' ');        error(' ');    end;end;eog=ep_findEOGchans(data.eloc);elecDistances=ep_closestChans(data.eloc);if isempty(eog)    error('No EOG channels specified.');end;msg=['The blink channels are: LUVEOG(' num2str(eog.LUVEOG) ') RUVEOG(' num2str(eog.RUVEOG) ') LLVEOG(' num2str(eog.LLVEOG) ') RLVEOG(' num2str(eog.RLVEOG) ').'];disp(msg);finalLog{end+1}=msg;msg=['The saccade channels are: LHEOG(' num2str(eog.LHEOG) ') RHEOG(' num2str(eog.RHEOG) ').'];disp(msg);finalLog{end+1}=msg;msg=['Minimum number of good trials per cell to avoid warning message is: ' num2str(minTrialsPerCell) '.'];disp(msg);finalLog{end+1}=msg;if badDataCriteria.window    msg=['Moving average window for smoothing during bad channel detection: ' num2str(badDataCriteria.window) ' ms.'];else    msg='Moving average window for smoothing during bad channel detection: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.window    msg=['Difference from minimum to maximum for bad channel: ' num2str(badDataCriteria.minmax) ' 였.'];else    msg='Difference from minimum to maximum for bad channel: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.window    msg=['Percent of bad channels exceeded to declare bad trial, rounding down: ' num2str(badDataCriteria.badnum) '%.'];else    msg='Percent of bad channels exceeded to declare bad trial, rounding down: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.window    msg=['Difference from minimum to maximum for bad horizontal EOG: ' num2str(badDataCriteria.hminmax) ' 였.'];else    msg='Difference from minimum to maximum for bad horizontal EOG: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.neighbors    msg=['Number of electrodes considered to be neighbors: ' num2str(badDataCriteria.neighbors) '.'];else    msg='Number of electrodes considered to be neighbors: NONE.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.badchan    msg=['Minimum predictability from neighbors to not be considered globally bad: ' num2str(badDataCriteria.badchan) '.'];else    msg='Minimum predictability from neighbors to not be considered globally bad: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.maxneighbor    msg=['Maximum difference from most similar neighboring electrode to be considered bad: ' num2str(badDataCriteria.maxneighbor) ' 였.'];else    msg='Maximum difference from most similar neighboring electrode to be considered bad: OFF.';end;disp(msg);finalLog{end+1}=msg;msg=['Blink template option is: ' template '.'];disp(msg);finalLog{end+1}=msg;if badDataCriteria.blink && ~strcmp(template,'none')    msg=['Threshold correlation with blink template: ' num2str(badDataCriteria.blink) '.'];else    msg='Blink correction: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.detrend    msg=['Detrend data: ON.'];else    msg='Detrend data: OFF.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.badtrials    msg=['Percentage of good trials chan is bad to declare a channel globally bad: ' num2str(badDataCriteria.badtrials) '%.'];else    msg='Percentage of good trials chan is bad to declare a channel globally bad: NONE.';end;disp(msg);finalLog{end+1}=msg;if badDataCriteria.movefacs && strcmp(badDataCriteria.trialMode,'fix')    msg=['Number of factors to retain when correcting movement artifacts: ' num2str(badDataCriteria.movefacs) '.'];else    msg='Movement artifact correction: NONE.';end;disp(msg);finalLog{end+1}=msg;msg=['Bad channels and trials: ' badDataCriteria.channelMode '.'];disp(msg);finalLog{end+1}=msg;if badDataCriteria.noadjacent    msg=['Do not allow adjacent bad channels (trial declared bad): ON.'];else    msg='Do not allow adjacent bad channels (trial declared bad): OFF.';end;disp(msg);finalLog{end+1}=msg;temp=fix(clock);if length(sessionFiles) > 1    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' num2str(length(sessionFiles)) '-files ' date sprintf('-%d-%d-%d',temp(4:6)) '.txt'],'w');else    [pathstr, fileName, ext, versn]=fileparts(sessionFiles{1});    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' deblank(fileName) ' ' date sprintf('-%d-%d-%d',temp(4:6)) '.txt'],'w');end;if (fid == -1)    disp('Error: Unable to start log file.');    returnend;for session = 1:sessionNum    Name=deblank(sessionFiles{session});    [pathstr, fileName, ext, versn]=fileparts(Name);        msg='**************************************************************';    disp(msg);    finalLog{end+1}=msg;    msg=['Working on: ' Name '.'];    disp(msg);    finalLog{end+1}=msg;        if session > 1        thisReadArg=readArg;        thisReadArg{end+1}='file';        thisReadArg{end+1}=Name;        thisReadArg{end+1}='ced';        thisReadArg{end+1}=data.ced; %assume they all have the same channel coordinates        thisReadArg{end+1}='montage';        thisReadArg{end+1}=data.montage; %assume they all have the same montage        data=ep_readData(thisReadArg);        [data]=ep_stripAdds(data);    end;    if ~any(strcmp(data.dataType,{'single_trial','continuous','average'}))        disp(' ');        disp('**************************************************************');        disp(['Error: The file type ' data.dataType ' is not currently supported by this function.']);        disp('**************************************************************');        disp(' ');        return;    end;        if length(data.facNames) > 1        disp(' ');        disp('**************************************************************');        disp(['Error: This function is not intended for application to factor data.']);        disp('**************************************************************');        disp(' ');        return;    end;        if isempty(data.data)        disp(' ');        disp('**************************************************************');        disp(['Error: The file had no data left to correct after additions were removed.']);        disp('**************************************************************');        disp(' ');        return;    end;        if strcmp(data.dataType,'continuous') && ~isempty(baseline)        thisBaseline=[];        msg=['This is continuous data so baseline correction is being deactivated.'];        disp(msg);        finalLog{end+1}=msg;    end;        if strcmp(data.dataType,'continuous') && strcmp(badDataCriteria.trialMode,'fix')        badDataCriteria.trialMode='none';        msg=['This is continuous data so movement correction is being deactivated.'];        disp(msg);        finalLog{end+1}=msg;    end;        if strcmp(data.dataType,'continuous')        badDataCriteria.maxneighbor=inf;        badDataCriteria.minmax=inf;        badDataCriteria.hminmax=inf;        msg=['This is continuous data so trialwise bad channel detection is being deactivated.'];        disp(msg);        finalLog{end+1}=msg;    end;        if isempty(strcmp(data.trialSpecNames,'edit'))        data.trialSpecNames{end+1}='edit';        data.trialSpecs(:,end+1)=-1;    end;        numSamples=length(data.timeNames);    numChans=length(data.chanNames);        if ~any(strcmp('reference',inputSet)) %if reference not specified, default to data file's settings.        refChan= find(strcmp('REF',cellstr(data.chanTypes)));    end;        if ~isempty(refChan)        if length(refChan) > 1            msg=['The channels ' num2str(refChan(:)') ' are marked as being references.'];        elseif length(refChan) ==1            msg=['The channel ' num2str(refChan) ' is marked as being the reference.'];        end;        disp(msg);        finalLog{end+1}=msg;    end;        [chunkNum] = ep_chunkInputFile(data, Name, chunkSize);        for theSubject=1:length(data.subNames)        badSubject=0;        if length(data.subNames) > 1            msg=['   Subject: ' data.subNames{theSubject}];            disp(msg);            finalLog{end+1}=msg;        end;        %detect bad channels        badChansDetected=[];        [badChansDetected shortChansDetected outputLog]=ep_detectBadChans(data, badDataCriteria,theSubject);        finalLog(end+1:end+length(outputLog))=outputLog;        if badChansDetected == -1            msg=['This file encountered an error while trying to detect bad channels and so will not be artifact corrected.'];            disp(msg);            finalLog{end+1}=msg;            badSubject=1;        end;                theBadChans=unique([badChansDetected badChans{theFile}]);        theBadChans=theBadChans(find(theBadChans>0)); %exclude zero as a bad channel        if ~isempty(theBadChans)            msg=['Global bad Channels: ' num2str(theBadChans)];        else            msg='Global bad Channels: None';        end;        finalLog{end+1}=msg;                if (max(baseline) > numSamples)            msg=['Baseline samples larger than epoch size itself for ' Name '.\n  Setting equal to the epoch size.'];            disp(msg);            finalLog{end+1}=msg;            baseline=baseline(find(baseline<=numSamples));        end;                if badDataCriteria.badnum            if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                if length(data.subNames) > 1                    msg=['For subject ' data.subNames{theSubject} ' there were too many bad channels.'];                else                    msg=['This file has too many bad channels.'];                end;                disp(msg);                finalLog{end+1}=msg;                badSubject=1;            end;        end;                if badDataCriteria.neighbors && badDataCriteria.noadjacent && ~isempty(theBadChans) %neighboring bad channels?            warn=0;            for chan=theBadChans                [B IX]=sort(elecDistances(chan,:));                neighbors=IX(2:badDataCriteria.neighbors+1);                if ~isempty(intersect(theBadChans,neighbors))                    warn=1;                    break                end;            end;            if warn                if length(data.subNames) > 1                    msg=['Warning: Subject ' data.subNames{theSubject} ' has neighboring globally bad channels.'];                else                    msg=['Warning: Subject has neighboring globally bad channels.'];                end;                disp(msg);                finalLog{end+1}=msg;            end;        end;                if ~badSubject            if noFigure                butterflyFig=[];            else                for chunk=1:chunkNum                    butterflyFig(chunk)=figure('Name','Artifact Correction','NumberTitle','off','Position',[201 1 400 scrsz(4)], 'MenuBar', 'none');                    if length(data.subNames) > 1                        title([deblank(fileName) '(sub ' data.subNames{theSubject} ')-' num2str(chunk)],'Interpreter','none');                    else                        title([deblank(fileName) '-' num2str(chunk)],'Interpreter','none');                    end;                    for i=1:8                        subplot(8,1,i)                    end;                end;            end;                        %fix blink artifacts            if badDataCriteria.blink && ~strcmp(template,'none')                if ((any(theBadChans==eog.LUVEOG) && any(theBadChans==eog.RUVEOG)) || (any(theBadChans==eog.LLVEOG) && any(theBadChans==eog.RLVEOG))) && strcmp(template,'autoTemplate')                    msg=['The file ' Name ' needs at least one good upper and one good lower EOG channel.'];                    disp(msg);                    finalLog{end+1}=msg;                else                    [blinkTrialNum outputLog] = ep_fixBlink(Name, 1, chunkNum, badDataCriteria, theBadChans, eog, template, blinkFile, baseline, saturation, refChan, butterflyFig, theSubject);                    finalLog(end+1:end+length(outputLog))=outputLog;                end            end;                        %detrend data            if badDataCriteria.detrend                [outputLog] = ep_detrendChunk(Name, 1, chunkNum, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;            end;                        %fix movement artifacts            if badDataCriteria.trialminmax && strcmp(badDataCriteria.trialMode,'fix')                [moveTrialNum outputLog] = ep_fixMovement(Name, 1, chunkNum, badDataCriteria, theBadChans, butterflyFig, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;            else                moveTrialNum=[];            end;                        %detect bad channels and trials            [outputLog, theBadChans, badChanNum, badTrialNum] = ep_detectBadDataChunk(Name, 1, chunkNum, badDataCriteria, theBadChans, baseline, theSubject);            finalLog(end+1:end+length(outputLog))=outputLog;                        if badDataCriteria.badnum                if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                    msg=['This subject has too many bad channels.'];                    disp(msg);                    finalLog{end+1}=msg;                    badSubject=1;                end;            end;                        if badDataCriteria.neighbors && badDataCriteria.noadjacent %neighboring bad channels?                warn=0;                for chan=theBadChans                    [B IX]=sort(elecDistances(chan,:));                    neighbors=IX(2:badDataCriteria.neighbors+1);                    if ~isempty(intersect(theBadChans,neighbors))                        warn=1;                        break                    end;                end;                if warn                    msg='Warning: Subject has neighboring globally bad channels.';                    disp(msg);                    finalLog{end+1}=msg;                end;            end;                        if strcmp(data.dataType,'single_trial')                [uniqueCellNames, m, CellNameIndex] = unique(data.cellNames);                cellGoodTrialCount=hist(CellNameIndex,length(unique(data.cellNames)));                for theTrial=1:length(badTrialNum)                    if badTrialNum(theTrial)                        cellGoodTrialCount(CellNameIndex(theTrial))=cellGoodTrialCount(CellNameIndex(theTrial))-1;                    end;                end;                                for theCell=1:length(cellGoodTrialCount)                    if cellGoodTrialCount(theCell) < minTrialsPerCell                        if cellGoodTrialCount(theCell) == 0                            msg=['Warning: Cell ' uniqueCellNames{theCell} ' has no good trials.'];                        elseif cellGoodTrialCount(theCell) == 1                            msg=['Warning: Cell ' uniqueCellNames{theCell} ' has only 1 good trial.'];                        else                            msg=['Warning: Cell ' uniqueCellNames{theCell} ' has only ' num2str(cellGoodTrialCount(theCell)) ' good trials.'];                        end;                        disp(msg);                        finalLog{end+1}=msg;                    end;                end;            end;                        if ~badSubject                %detect horizontal eye movements                if badDataCriteria.hminmax                    [outputLog] = ep_zeroHEOGchunk(Name, 1, chunkNum, badDataCriteria, theBadChans, eog, theSubject);                    finalLog(end+1:end+length(outputLog))=outputLog;                end;                                theDots=findstr(Name,'.');                outName=Name;                if ~isempty(theDots)                    outName=Name(1:theDots(end)-1); %drop the suffix                end;                                %replace or mark bad channels                if ~strcmp(data.dataType,'continuous')                    if strcmp(badDataCriteria.channelMode,'replace')                        ep_replaceBadDataChunks(Name, 1, chunkNum, theBadChans, theSubject, butterflyFig);                    elseif strcmp(badDataCriteria.channelMode,'mark')                        ep_markBadDataChunks(Name, 1, chunkNum, theBadChans, theSubject);                    end;                end;            end;            if ~noFigure                for chunk=1:chunkNum                    try                        set(butterflyFig(chunk),'PaperPositionMode','auto');                        if length(data.subNames) > 1                            eval (['print -f' num2str(butterflyFig(chunk)) ' -djpeg ''' Name '''(' data.subNames{theSubject} ')-' num2str(chunk) '.jpg']);                        else                            eval (['print -f' num2str(butterflyFig(chunk)) ' -djpeg ''' Name '''-' num2str(chunk) '.jpg']);                        end;                    catch                        disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');                    end;                    close(butterflyFig(chunk));                end;            end;        end; %~bad subject        for line=1:length(finalLog)            finalLog{line}=strrep(finalLog{line},'\','\\'); %slashes are mistaken as control characters.            finalLog{line}=strrep(finalLog{line},'%','%%'); %percentages are mistaken as control characters.            fprintf(fid,[finalLog{line} '\n']);        end        finalLog=[];    end; %subject    outName=[pathstr filesep fileName '_e'];    ep_rejoinChunks(Name, outName, outputFormat, chunkNum);        for chunk = 1:chunkNum        delete([Name '-' num2str(chunk) '.mat']); %clean up temporary work files    end;    end; %sessionmsg='Done.';disp(msg);fprintf(fid,[msg '\n']);fclose(fid);