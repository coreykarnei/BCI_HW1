function [chunkNum] = ep_chunkInputFile(data, fnameout, chunkSize)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [chunkNum] = ep_chunkInputFile(data, fnameout, chunkSize)%                         writes out EP format data in chunks.%%   writes out data in chunks of chunkSize samples in length, except for%   the final two which are the size of the remaining samples divided in two.%	This is done to ensure that each chunk will be of sufficent size to%	characterize blinks with ICA.  Output file consists of the data structure%   with relevant fields (e.g., data, cellNames, etc. subset into chunks).%%Inputs%  data         : Structured array with the data and accompanying information.%    .data      : 5D data matrix [channels, time points, cells/trials, subjects, factors].%                 Trials are grouped by cell in single_trial format.%    .montage   : String with the montage information, if available.%    .fileFormat: The file format.%    .dataType  : The type of the data: 'continuous', 'single_trial', or 'average' (default: average)%    .chanNames : The channel names.%    .timeNames : The timepoint msec with respect to the stimulus onset time.%    .subNames  : The subject names%    .cellNames : The cell names (once for each trial for single_trial files).%    .trialNames: The trial number ID per cell (starting from 1). (single_trial data only)%    .facNames  : The factor names (only for factor files)%    .chanTypes : The type of the channel: EEG, MEG, ANS (autonomic), REF (explicit reference), REG (regional average)%    .subTypes  : The type of the subject: RAW (single trial), AVG (subject average), GAV (grand average)%    .cellTypes : The type of the cell: SGL (one cell), CMB (combination of cells)%    .facTypes  : The type of the factor: SGL (one factor), CMB (combination of factors)%    .EPver     : The EP Toolkit version information.%    .ver       : The Matlab version information.%    .date      : The date the file was created.%    .Fs        : The sampling frequency in Hz.%    .baseline  : The number of samples prior to the trigger event (positive number).%    .ename     : The name of the experiment.%    .trialSpecs       : Cell array (trial,spec) of specific information for trials (single_trial data only)%    .trialSpecNames   : Cell array of the name of each trial spec type.%    .subjectSpecs     : Cell array (subject,spec) of specific information for subjects%    .subjectSpecNames : Cell array of the name of each subject spec type.%    .events    : Cell array of event structured variables (subject,cell/trial)%      .type      = string (events of "trial" type dropped as they are redundant with cell name information.)%      .sample    = expressed in samples, the first sample of a recording is 1%      .value     = number or string%      .offset    = expressed in samples (0=first sample of epoch, negative means event after first sample of epoch)%      .duration  = expressed in samples%      .timestamp = expressed in timestamp units, which vary over systems (optional)%    .avgNum    : Number of waveforms going into averages (subject,cell)%                 0 means unknown and -1 means bad.%    .subNum    : Number of subjects going into averages (subject,cell)%                 0 means unknown and -1 means bad.%    .fileName  : Name of original file.%    .history   : Command used to create current file.%    .ced       : The name of the .ced file for electrode coordinates.%    .eloc      : The electrode location information, one for each channel (see readlocs header)%    .implicit  : The electrode information for implicit references and fiducial locations (see readlocs header)%	fnameout: Filename of output file.%	chunkSize: Number of samples to put in each sub file.%%Outputs%	chunkNum: Number of chunks created.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 5/26/02 JD% added cross-platform endian support.  chunks will no longer cut trials in half.  % Correction made so filenames with a period do not cause errors.%% modified 10/11/02 JD% Moved chunk size check into this function so would not have to manually% specify trial size in blinkCorrection script.%% modified 10/20/02 JD% chunkSize does not have to be exact.  Program will figure exact number.%% modified 5/27/03 JD% Changed name to segmentEGISses from readEGISses for clarity's sake.  Fixed size% of last chunk when the last two are different sizes to avoid cutting a trial% in two.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% modified (8/20/08) JD% Changed format of rd_PCAegis_hdr_v call.  Cleaned up endian code.%% modified (11/18/08) JD% Changed to use FieldTrip I/O in order to be able to read more formats.% Changed name to chunkInputFile to reflect this more general function.%% bugfix (11/24/08) JD% size of last chunk for multiple chunks not being figured correctly.%% modified (1/31/09) JD% allows for data with multiple events per trial but only one at stimulus onset.%% modified (2/9/09) JD% Dropped trialsize output field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 9/22/09 JD% Modified to handle continuous files.% Size of last two chunks for multiple chunks not being figured correctly.%% bugfix 10/31/09 JD% Crash when only one chunk and less trials than maximum allowed by chunk size.% Crash when more than two chunks.%% bugfix 11/2/09 JD% When there are multiple chunks, the last two are miscalculated such that they are data from earlier chunks.% Thanks to Siri Kamp.%% bugfix 11/10/09 JD% When there are multiple chunks, crash when there is an odd number of trials.%% bugfix 3/9/10 JD% When there are multiple chunks, crash when there is an odd number of trials.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2008  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.if strcmp(data.dataType,'continuous')    dataLength = length(data.timeNames);    if dataLength< chunkSize        chunkSize=dataLength;    end;    numFiles = ceil(dataLength/chunkSize);        if (mod(dataLength,chunkSize) ~= 0) && (numFiles > 1)        lastSize1 = (dataLength - ((numFiles-2)*chunkSize))/2; %divide the remaining trials evenly amongst the final two chunks        lastSize2 = (dataLength - ((numFiles-2)*chunkSize))/2;    else        lastSize1 = chunkSize;        lastSize2 = chunkSize;    end;        %    % Read in and write out the data    %    pointCounter=0;    for chunk = 1:numFiles        if chunk == (numFiles-1)            nPoints = lastSize1;        elseif chunk == (numFiles)            nPoints = lastSize2;        else            nPoints = chunkSize;        end;        dataChunk = data;        dataChunk.data=dataChunk.data(:,1+pointCounter:pointCounter+nPoints,:,:);        dataChunk.timeNames=dataChunk.timeNames(1+pointCounter:pointCounter+nPoints);        if chunk > 1            dataChunk.events=[]; %first data chunk will contain the events            dataChunk.trialSpecs=[]; %first data chunk will contain the trial specs            dataChunk.analysis.badChans=[];            dataChunk.analysis.badTrials=[];            dataChunk.analysis.blinkTrial=[];            dataChunk.analysis.moveTrial=[];        end;        eval (['save ''' fnameout '''-' num2str(chunk) '.mat dataChunk']);        pointCounter=pointCounter+nPoints;    end;    else    trialSize = length(data.timeNames);    numChunkTrials = floor(chunkSize/trialSize);   %number of trials in a chunk    numTrials = length(data.cellNames);    numFiles = ceil(numTrials/numChunkTrials);    if numChunkTrials > numTrials        numChunkTrials = numTrials;    end;        if (mod(numTrials,numChunkTrials) ~= 0) && (numFiles > 1)        lastSize1 = floor((numTrials - ((numFiles-2)*numChunkTrials))/2); %divide the remaining trials evenly amongst the final two chunks        lastSize2 = ceil((numTrials - ((numFiles-2)*numChunkTrials))/2);    else        lastSize1 = numChunkTrials;        lastSize2 = numChunkTrials;    end;        %    % Read in and write out the data    %    trialCounter=0;    for chunk = 1:numFiles        if chunk == (numFiles-1)            nTrials = lastSize1;        elseif chunk == (numFiles)            nTrials = lastSize2;        else            nTrials = numChunkTrials;        end;        dataChunk = data;        dataChunk.data=dataChunk.data(:,:,1+trialCounter:trialCounter+nTrials,:);        dataChunk.cellNames=dataChunk.cellNames(1+trialCounter:trialCounter+nTrials);                if strcmp(dataChunk.dataType,'single_trial')            dataChunk.trialNames=dataChunk.trialNames(1+trialCounter:trialCounter+nTrials);            dataChunk.trialSpecs=dataChunk.trialSpecs(1+trialCounter:trialCounter+nTrials,:);        end;        dataChunk.events=dataChunk.events(:,1+trialCounter:trialCounter+nTrials);                dataChunk.analysis.badChans=dataChunk.analysis.badChans(1,1+trialCounter:trialCounter+nTrials,:);        dataChunk.analysis.badTrials=dataChunk.analysis.badTrials(1+trialCounter:trialCounter+nTrials);        dataChunk.analysis.blinkTrial=dataChunk.analysis.blinkTrial(1+trialCounter:trialCounter+nTrials);        dataChunk.analysis.moveTrial=dataChunk.analysis.moveTrial(1+trialCounter:trialCounter+nTrials);        eval (['save ''' fnameout '''-' num2str(chunk) '.mat dataChunk']);        trialCounter=trialCounter+nTrials;    end;    end;%% Return success%chunkNum = numFiles;