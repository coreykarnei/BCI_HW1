function [totblinkTrialNum, outputLog] = ep_fixBlink(inFile, startChunk, endChunk, badDataCriteria, badChans, eog, template, blinkFile, baseline, saturation, refChan, butterflyFig, theSubject)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totblinkTrialNum, outputLog] = ep_fixBlink(inFile, startChunk, endChunk, badDataCriteria, badChans, eog, template, blinkFile, baseline, saturation, refChan, butterflyFig, theSubject)%%	Reads in file chunks generated by chunkInputFile function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   template:   source of blink template (fileTemplate: load 'blinks' file.  autoTemplate: automatically generate blink template.%                  bothTemplate: use both file and automatic template at the same time).%   blinkFile:  file with blink template.  Assumed to be in the same directory as the data file.%   baseline:   array of sample numbers to permanently baseline correct the trials with.  [] means don't correct.%   saturation: followed by range of non-saturated data values%   refChan:    Array of reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   theSubject: which subject of the file is being processed.%%   The input chunks are EP format data files.%%Outputs%	totblinkTrialNum: Total list of blink trials.%	Saves files with blinks removed, replacing the original chunked files.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%   outputLog: output messages from blink fixing process%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 6/22/01 JD% added bad channel and threshold parameters.  Also changed chunkNum to startChunk and endChunk.%% modified 5/27/02 JD% added baseline correct feature.  Fix to bad chans so they are zeroed even if no blink factors.%% bugfix 10/11/02 JD% added fix to baseline feature for when a blink occurs during the baseline% period.  Output files will now be baselined.  Also, added check for chans% with zero variability.%% modified 10/20/02 JD% since ICA removal sometimes degrades trials without blinks, will now% remove blink components only for trials where the largest feature has the% topography of a blink (correlates .9 with raw EEG).%% modified 12/06/02 JD% Can automatically generate individualized blink template.  Maxed out VEOG time% points dropped from correction and baseline process and left intact (to trigger% eyeblink rejection in averaging program) since they can't be corrected% properly.  Added output log.%% modified 02/04/03  JD% Can now specify blink template file name.  Saves topoplots of blink facs.%  Added bothTemplate option.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 11/15/05 JD% Fixed bug that crashed program when a customized blink template was% specified.%% bugfix 7/24/06 JD% Contents of blink template no longer prints out on screen.  Added some error checking.%% modified 3/22/07 JD% Finished autotemplate feature.  Also now takes into account possibility% of blink recoveries (with an inverse topography).  Also now handles% different montages through EEG_hardware function.%% modified 2/17/08 JD% Checks to see if binary version of runica is installed and uses it if available.%% modified 11/17/08 JD% Eliminated topoplot of blink factors. Made baseline specification more flexible.%% modified 12/13/08 JD% Increased scaling for blink plots to make them more visible.%% modified 2/11/09 JD% Dropped trialsize input field.  No longer zeroes bad channels.  Replaced% threshold field with full badDataCriteria field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 3/17/09 JD% Only subtracted blink activity (that met variance reduced criterion) is shown for blink data figure.%% bugfix 4/16/09 JD% Fixed crash when overall blink direction equaled exactly zero.%% bugfix &  modified 7/14/09 JD% Fixed bothTemplate option, which was functioning the same as autoTemplate, ignoring the file template.% Changed output from list of blink facs to list of blink trials.  No longer zeroes out bad channels.% Includes list of blink trials in the data chunk.  Output figure can now be passed from function call.% blink file assumed to be in the directory of the data file.  Uses updated blink template format.%% modified 8/28/09 JD% Modified to use new option for binary runICA to control the output file names so that they can be cleaned up% and so that unpredictable crash from bug causing strange file names can be circumvented.%% modified 9/4/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.%% bugfix 10/17/09 JD% Crash when only one VEOG channel.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 11/20/09 JD% Replaced "union" commands with "unique" commands because certain situations caused the "union" command to crash in% Matlab 2007.%% bugfix 12/3/09 JD% Additional check for ICA failure (denoted by imaginary numbers for weights).%% modified 2/11/10 JD% Will now work with subject average files with multiple subjects.% BlinkTrial no longer initialized to zero.%% modified & bugfix 5/15/10 JD% Made more memory efficient by reducing resolution of the blink plots to no more than 10000 points regardless of size of data.% Fixed when data is mean mastoid, not setting second reference channel to be inverse of the first reference channel.% Fixed crashes when explicit reference channel is present.% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2010  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.msg='Fixing eyeblink.';disp(msg);outputLog{1}=msg;totblinkTrialNum=[];if nargin < 12    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');end;VEOG(1) = eog.LUVEOG;VEOG(2) = eog.RUVEOG;VEOG(3) = eog.LLVEOG;VEOG(4) = eog.RLVEOG;for i=1:4    goodEOG(i)=i*~any(VEOG(i) == badChans);end;goodEOG=goodEOG(find(goodEOG));VEOG=VEOG(goodEOG);if any(strcmp(template, {'fileTemplate','bothTemplate'}))    [fileDir, name, ext, versn] = fileparts(inFile);    eval(['load ''' blinkFile '''']);    if ~exist('EPblink','var')        error('Not a blink template.');    end;    eval(['load ''' deblank(inFile) '''-' num2str(1) '.mat']);    if length(EPblink.eloc) ~= length(dataChunk.eloc)        msg=['Number of blink template electrodes (' num2str(length(EPblink.eloc)) ') different from the data (' num2str(length(dataChunk.eloc)) ').'];        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;    if any([EPblink.eloc.theta]-[dataChunk.eloc.theta])        msg='Blink template electrode locations not consistent with the data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;    blinks=EPblink.template;    if size(blinks,1) > 1        blinks = blinks';    end;    if size(blinks,1) > 1        msg='Something is wrong with the blink template.  It has the wrong dimensions.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;end;if any(strcmp(template, {'autoTemplate','bothTemplate'}))    signs = [ 1 1 -1 -1;1 1 -1 -1; -1 -1 1 1; -1 -1 1 1];    signs=signs(goodEOG,:);    signs=signs(:,goodEOG);    blinksign = [1 1 -1 -1]';    blinksign=blinksign(goodEOG,1);end;if ~any(strcmp(template, {'autoTemplate','bothTemplate','fileTemplate'}))    msg='Template variable must be set to fileTemplate, autoTemplate, or bothTemplate.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    return;end;facsdone = [];badChans = badChans(find(badChans));	%drop out bad channels set as being zeroif length(refChan) == 2    badChans = unique([badChans,refChan(2)]);     %temporarily take second reference site out of ICAend;outputLog=[];warning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.for chunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(chunk)];        disp(msg);        outputLog{end+1}=msg;    end;    eval(['load ''' deblank(inFile) '''-' num2str(chunk) '.mat']);        numChans=length(dataChunk.chanNames);    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);            displayPeriod=size(trialdata,2);    %Number of timepoints to graph in display.    decimateSamples=ceil(max(1,displayPeriod/10000));    if displayPeriod == 1        msg='There is only one time point and so the data cannot be eyebink corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        trialSize = length(dataChunk.timeNames);    numTrials = length(dataChunk.cellNames);        if (length(refChan) == 1) && std(trialdata(refChan(1),:)') == 0        badChans = unique([badChans,refChan(1)]);     %temporarily take first reference site out of ICA    end;        chans = [1:numChans];    chans(badChans)=0;    chans = chans(find(chans));    if length(VEOG) ==1        goodPoints = find(trialdata(VEOG,:) < saturation(2) & trialdata(VEOG,:) > saturation(1));    else        goodPoints = find((max(trialdata(VEOG,:)) < saturation(2)) & (min(trialdata(VEOG,:)) > saturation(1)));    end;    if ~isempty(butterflyFig)        figure(butterflyFig(chunk));        [pathstr, fileName, ext, versn]=fileparts(inFile);        subplot(8,1,1), plot([1:decimateSamples:displayPeriod],trialdata([badChans chans],1:decimateSamples:displayPeriod));        axis([1 displayPeriod -200 200])        title([deblank(fileName) '-' num2str(chunk)],'Interpreter','none');    end;    if ~isempty(baseline)			%subtract out baselines before performing ICA        for i = 1:numTrials            epoch=goodPoints(find((goodPoints>((i-1)*trialSize)) & (goodPoints<=(i*trialSize))));            base=goodPoints((i-1)*trialSize+baseline);            if ~isempty(epoch) && ~isempty(base)                baseMeans = mean(trialdata(:,base),2);                trialdata(:,epoch)=trialdata(:,epoch)-diag(baseMeans)*ones(size(trialdata,1),length(epoch));            end;        end;        if ~isempty(butterflyFig)            subplot(8,1,2), plot([1:decimateSamples:displayPeriod],trialdata([badChans chans],1:decimateSamples:displayPeriod));            axis([1 displayPeriod -200 200])            title('with baselines subtracted','Interpreter','none');        end;    else        if ~isempty(butterflyFig)            subplot(8,1,2), plot([1:decimateSamples:displayPeriod],trialdata([badChans chans],1:decimateSamples:displayPeriod));            axis([1 displayPeriod -200 200])            title('no baseline subtraction specified','Interpreter','none');        end;    end;    icadefs;    if exist(ICABINARY) == 2 && ~any(isspace(pwd)) %is there a binary file of runica installed?        [weights sphere] = binica(trialdata(chans,[goodPoints]),'verbose', 'on','filenum',9501);        delete('binica9501.wts');        delete('binica9501.sph');        delete('bias_after_adjust');        delete('binica9501.sc');    else        [weights sphere] = runica(trialdata(chans,[goodPoints]));    end;    if all(diag(weights) == 1) || ~all(isreal(weights))        disp(' ');        disp('**************************************************************');        disp(['Error: ICA was unable to converge on a solution for chunk ' num2str(chunk) '.']);        disp('**************************************************************');        disp(' ');    end;    winv = inv(weights * sphere);    activations = weights * sphere * trialdata(chans,:);    if strcmp(template,'autoTemplate') || strcmp(template,'bothTemplate')        blinkTrials = zeros(numTrials,1);        blinkDirs = zeros(numTrials,1);        for i = 1:numTrials %check each trial for presence of blink            epoch=goodPoints(find((goodPoints>((i-1)*trialSize)) & (goodPoints<=(i*trialSize))));            if ~isempty(epoch)                if ~any((corrcoef(trialdata(VEOG,epoch)').*signs) < 0)%if all 4 EOG channels correlate in the right direction for a blink or its recovery                    trial = diag(blinksign)*trialdata(VEOG,epoch);                    [maxamp maxpoint] = max(abs(sum(trial)));                    blinkDirs(i)=sign(maxamp); %direction of blink activity                    if sign(maxamp) ~= 0                        blinkTrials(i)=epoch(maxpoint); %amplitude of blink activity                    end;                end;            end;        end;        blinkTrials=blinkTrials(find(blinkTrials)); %compact array to eliminate trials with no blinks        blinkDirs=blinkDirs(find(blinkDirs));        if ~isempty(blinkTrials)            if length(blinkTrials) == 1                msg='1 blink trial used for template generation.';            else                msg=[num2str(length(blinkTrials)) ' blink trials used for template generation.'];            end            disp(msg);            outputLog{end+1}=msg;            if length(blinkTrials) == 1                autoBlinks=trialdata(:,blinkTrials)';            else                autoBlinks=mean(diag(blinkDirs)*trialdata(:,blinkTrials)');            end;            corrs = corrcoef([autoBlinks(chans)' winv]);            blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        else            msg='No blinks detected.';            disp(msg);            outputLog{end+1}=msg;            autoBlinks=zeros(1,size(trialdata,1));            blinkfacs=[];        end;    end;    if template == 'fileTemplate'        corrs = corrcoef([blinks(chans)' winv]);        blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);    end;    if template == 'bothTemplate'        corrs = corrcoef([blinks(chans)' winv]);        blinkfacs2 = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        blinkfacs = unique([blinkfacs, blinkfacs2]);    end;    blinkTrialNum{chunk}=dataChunk.analysis.blinkTrial;    if not(isempty(blinkfacs))	%if there are blink factors, subtract them out        winvFull = zeros(numChans,size(winv,1));        for i = 1:length(chans)            winvFull(chans(i),:)=winv(i,:);        end;        temp = zeros(size(activations,1),1);        temp(blinkfacs) = 1;        blinkdata = (winvFull * diag(temp) * activations);        subtractedBlinks = zeros(size(blinkdata));        count=0;        for i = 1:numTrials %correct trials for blink if it reduces overall variance            epoch=goodPoints(find((goodPoints>((i-1)*trialSize)) & (goodPoints<=(i*trialSize))));            if ~isempty(epoch)                data = trialdata(chans,epoch);                noblinkdata= data - blinkdata(chans,epoch);                if sum(var(data)) >= sum(var(noblinkdata))                    trialdata(chans,epoch) = noblinkdata;                    subtractedBlinks(chans,epoch) = blinkdata(chans,epoch);                    count=count+1;                    blinkTrialNum{chunk}(theSubject,i)=1;                end;            end;        end;        if ~strcmp(dataChunk.dataType,'continuous')            if count == 1                msg='1 trial corrected for blink activity.';            else                msg=[num2str(count) ' trials corrected for blink activity.'];            end            disp(msg);            outputLog{end+1}=msg;        end;        facsdone = [facsdone; winvFull(:,blinkfacs)'];        if ~isempty(butterflyFig)            figure(butterflyFig(chunk));            subplot(8,1,3), plot([1:decimateSamples:displayPeriod],subtractedBlinks([badChans chans],1:decimateSamples:displayPeriod));            title('subtracted blinks','Interpreter','none');            axis([1 displayPeriod -200 200])            subplot(8,1,4), plot([1:decimateSamples:displayPeriod],trialdata([badChans chans],1:decimateSamples:displayPeriod));            title('with blinks subtracted','Interpreter','none');            axis([1 displayPeriod -200 200])        end;    else        msg='No components match blink template so no correction performed.';        disp(msg);        outputLog{end+1}=msg;        if ~isempty(butterflyFig)            figure(butterflyFig(chunk));            subplot(8,1,3), plot([1:decimateSamples:displayPeriod],ones(1,ceil(displayPeriod/decimateSamples)));            axis([1 displayPeriod -200 200])            title('no blinks to subtract that were detected','Interpreter','none');            subplot(8,1,4), plot([1:decimateSamples:displayPeriod],trialdata([badChans chans],1:decimateSamples:displayPeriod));            title('no blinks subtracted','Interpreter','none');            axis([1 displayPeriod -200 200])        end;    end;    drawnow    if ~isempty(baseline)			%baseline again in case there were blinks in the baseline period.        for i = 1:numTrials            epoch=goodPoints(find((goodPoints>((i-1)*trialSize)) & (goodPoints<=(i*trialSize))));            base=goodPoints((i-1)*trialSize+baseline);            if ~isempty(epoch) && ~isempty(base)                baseMeans = mean(trialdata(:,base),2);                trialdata(:,epoch)=trialdata(:,epoch)-diag(baseMeans)*ones(size(trialdata,1),length(epoch));            end;        end;    end;    if length(refChan) == 2        trialdata(refChan(2),:)=-trialdata(refChan(1),:);     %put second reference channel back in.    end;    dataChunk.data(:,:,:,theSubject)=reshape(trialdata,numChans,trialSize,numTrials);    dataChunk.analysis.blinkTrial(theSubject,:)=blinkTrialNum{chunk};    eval (['save ''' inFile '''-' num2str(chunk) '.mat dataChunk;']);    if nargin < 12        try            eval (['print -f' num2str(butterflyFig(chunk)) ' -djpeg ''' inFile '''-' num2str(chunk) 'blink.jpg']);        catch            disp('Couldn''t save a copy of the blink correction figure.  Perhaps your version of Matlab is not current.');        end;    end;end;if nargin < 12    close(butterflyFig);end;totblinkTrialNum=[];for chunk = startChunk:endChunk    totblinkTrialNum=[totblinkTrialNum blinkTrialNum{chunk}];end;