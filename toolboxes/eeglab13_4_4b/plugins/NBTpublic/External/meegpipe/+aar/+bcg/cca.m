function myNode = cca(varargin)
% CCA - CCA-based BCG correction

import misc.process_arguments;
import misc.split_arguments;
import meegpipe.node.*;

opt.Correction = 80;
[thisArgs, varargin] = split_arguments(opt, varargin);

[~, opt] = process_arguments(opt, thisArgs);

myPCA = spt.pca('MaxCard', @(lambda) ceil(0.3*numel(lambda)));
tpcaFilter = filter.tpca('Order', @(sr) ceil(sr/10), 'PCA', myPCA);

delayFh = @(sr) unique(round(linspace(sr*0.65, sr*1.3, 30)));
myCCA = spt.bss.cca(...
    'Delay',        delayFh, ...
    'MinCorr',      (1-opt.Correction/100), ...
    'TopCorrFirst', true);

ccFilter = filter.cca(...
    'CCA',          myCCA, ...
    'CCFilter',     tpcaFilter);

% IMPORTANT: It is almost always a good idea to use the cca filter within a
% pca filter so that we avoid ill-conditioned covariance matrices. 
ccFilter = filter.pca(...
    'PCA',      spt.pca('RetainedVar', 99), ...
    'PCFilter', ccFilter);

ccFilter = filter.sliding_window(...
    'Filter',             ccFilter, ...
    'WindowLength',       @(sr) sr*20, ...
    'WindowOverlap',      75);

filterNode = filter.new(...
    'Filter',           ccFilter, ...
    'IOReport',         report.plotter.io, ...
    'ShowDiffReport',   true, ...
    'NbChannelsReport', 10, ...
    'EpochDurReport',   20);

myRegrEstimator = pipeline.new( ...
    copy.new, ...
    filterNode ...   
    );

myRegrFilter = filter.mlag_regr('Order', 10);
myRegrFilter = filter.sliding_window(...
    'Filter',        myRegrFilter, ...
    'WindowLength',  @(sr) sr*10, ...
    'WindowOverlap', 50);
myRegrFilter = filter.pca(myRegrFilter, ...
    'PCA', spt.pca('RetainedVar', 99));

mySel1 = pset.selector.sensor_class('Class', 'EEG');
mySel2 = pset.selector.good_data;
mySel  = pset.selector.cascade(mySel1, mySel2);

myNode = parallel_node_array.new(...
    'DataSelector', mySel, ...    
    'NodeList',     {[], myRegrEstimator}, ...
    'Aggregator',   @(out) filter(myRegrFilter, out{1}, out{2}), ...
    'CopyInput',    false, ...
    'IOReport',     report.plotter.io, ...
    varargin{:});
    


end